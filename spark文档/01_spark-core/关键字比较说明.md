#  关键字

> [TOC]
>
>   

## 1.1. transient

   #### . 瞬时态，被transient修饰的关键字，不参与序列化 ，主要作用，其一可以将无用的关键字段过滤，节省空间；节省序列化的时间；其二为了安全考虑，不去序列化相关的关键字，比如用户的银行卡卡号，手机号等等。

```java
class Person implements Serializable {    
    private transient String name;    
    private transient int age;    
    public Person() {    }
} 
```

```te
null --- 0 
null --- 0
null --- 0
```

## 1.2. volatile

具有可见性，有序性，不具备原则性  被volatile修饰的变量能够保证每个线程能够获取该变量的最新值，从而避免出现数据脏读的现象 

注意： volatile不具备原则性，这是volatile与java中的synchronize、java.util.concurrent.locks.Lock 

最大的功能差异 

原子性： 原子性通常指多个操作不存在的只执行一部分的情况，如果全部 执行完成那没毛病，如果只执行了一部分，得撤销已经执行的部分    

可见性： 当多个线程访问同一个变量x时，线程1修改了变量x的值，线程1、线程2...线程n 能够立即读取到线程1修改后的值 

有序性 ： 程序执行时按照代码的书写的先后顺序执行。

```java
public class VolatileDemo {
  private static volatile  boolean isOver = false;

    public static void main(String[] args) {
         Thread thread = new Thread(new Runnable() {
            @Override
            public void run() {
                while (!isOver){} ;

            }
        });

         thread.start();
        try {
            Thread.sleep(500);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        isOver = true;
    }
```





​       原子性： 如果你了解事务， 

## 1.3. atomic 

​     AtomicInteger 是对Int 类型的  封装，提供原子性的访问和更新操作，其原子性操作实现基于CAS

​     技术  

​     CAS :   所谓 CAS，表征的是一些列操作的集合，获取当前数值，进行一些运算，利用 CAS 指令试图进行更新。如果当前数值未变，代表没有其他线程进行并发修改，则成功更新。否则，可能出现不同的选择，要么进行重试，要么就返回一个成功或者失败的结果。

​     从AtomicInteger 的内部属性可以看出，它依赖于Unsafe提供的一些底层能力，进行底层操作

​    以 Volatile 的value 字段，记录数值，以保证可见性 

   ```java
private static final jdk.internal.misc.Unsafe U = jdk.internal.misc.Unsafe.getUnsafe();
private static final long VALUE = U.objectFieldOffset(AtomicInteger.class, "value");
private volatile int value;

   ```

getAndIncerment Unsafe 会利用value 字段的内存地址偏移 直接完成操作 

```java
public final int getAndIncrement() {
    return U.getAndAddInt(this, VALUE, 1);
}

```

因为 getAndIncrement 需要返归数值，所以需要添加失败重试逻辑 

```java
public final int getAndAddInt(Object o, long offset, int delta) {
    int v;
    do {
        v = getIntVolatile(o, offset);
    } while (!weakCompareAndSetInt(o, offset, v, v + delta));
    return v;
}

```

而类似 compareAndSet 这种返回 boolean类型的函数，因为返回值就是表现的成功与否 所以不需要重试。

```java
public final boolean compareAndSet(int expectedValue, int newValue)

```

CAS 是 Java 并发中所谓 lock-free 机制的



## 1.4. native 

native关键字说明其修饰的方法是一个原生态方法，方法对应的实现不是在当前文件，而是在用其他语言（如C和C++）实现的文件中。Java语言本身不能对操作系统底层进行访问和操作，但是可以通过JNI接口调用其他语言来实现对底层的访问。

## native用法：

1.编写带有native声明的方法的Java类（java文件）
2.使用javac命令编译编写的Java类（class文件）
3.使用javah -jni ****来生成后缀名为.h的头文件（.h的文件）
4.使用其他语言（C、C++）实现本地方法
5.将本地方法编写的文件生成动态链接库（dll文件）



